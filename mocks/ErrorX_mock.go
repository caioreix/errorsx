// Code generated by mockery. DO NOT EDIT.

package errorsxmock

import (
	errorsx "github.com/caioreix/errorsx"
	mock "github.com/stretchr/testify/mock"
)

// ErrorX is an autogenerated mock type for the ErrorX type
type ErrorX struct {
	mock.Mock
}

type ErrorX_Expecter struct {
	mock *mock.Mock
}

func (_m *ErrorX) EXPECT() *ErrorX_Expecter {
	return &ErrorX_Expecter{mock: &_m.Mock}
}

// Caller provides a mock function with no fields
func (_m *ErrorX) Caller() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Caller")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ErrorX_Caller_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Caller'
type ErrorX_Caller_Call struct {
	*mock.Call
}

// Caller is a helper method to define mock.On call
func (_e *ErrorX_Expecter) Caller() *ErrorX_Caller_Call {
	return &ErrorX_Caller_Call{Call: _e.mock.On("Caller")}
}

func (_c *ErrorX_Caller_Call) Run(run func()) *ErrorX_Caller_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ErrorX_Caller_Call) Return(_a0 string) *ErrorX_Caller_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_Caller_Call) RunAndReturn(run func() string) *ErrorX_Caller_Call {
	_c.Call.Return(run)
	return _c
}

// Error provides a mock function with no fields
func (_m *ErrorX) Error() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Error")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ErrorX_Error_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Error'
type ErrorX_Error_Call struct {
	*mock.Call
}

// Error is a helper method to define mock.On call
func (_e *ErrorX_Expecter) Error() *ErrorX_Error_Call {
	return &ErrorX_Error_Call{Call: _e.mock.On("Error")}
}

func (_c *ErrorX_Error_Call) Run(run func()) *ErrorX_Error_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ErrorX_Error_Call) Return(_a0 string) *ErrorX_Error_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_Error_Call) RunAndReturn(run func() string) *ErrorX_Error_Call {
	_c.Call.Return(run)
	return _c
}

// Fields provides a mock function with given fields: fields
func (_m *ErrorX) Fields(fields ...string) map[string]any {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Fields")
	}

	var r0 map[string]any
	if rf, ok := ret.Get(0).(func(...string) map[string]any); ok {
		r0 = rf(fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]any)
		}
	}

	return r0
}

// ErrorX_Fields_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fields'
type ErrorX_Fields_Call struct {
	*mock.Call
}

// Fields is a helper method to define mock.On call
//   - fields ...string
func (_e *ErrorX_Expecter) Fields(fields ...interface{}) *ErrorX_Fields_Call {
	return &ErrorX_Fields_Call{Call: _e.mock.On("Fields",
		append([]interface{}{}, fields...)...)}
}

func (_c *ErrorX_Fields_Call) Run(run func(fields ...string)) *ErrorX_Fields_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *ErrorX_Fields_Call) Return(_a0 map[string]any) *ErrorX_Fields_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_Fields_Call) RunAndReturn(run func(...string) map[string]any) *ErrorX_Fields_Call {
	_c.Call.Return(run)
	return _c
}

// Stack provides a mock function with no fields
func (_m *ErrorX) Stack() errorsx.Stack {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stack")
	}

	var r0 errorsx.Stack
	if rf, ok := ret.Get(0).(func() errorsx.Stack); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errorsx.Stack)
		}
	}

	return r0
}

// ErrorX_Stack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stack'
type ErrorX_Stack_Call struct {
	*mock.Call
}

// Stack is a helper method to define mock.On call
func (_e *ErrorX_Expecter) Stack() *ErrorX_Stack_Call {
	return &ErrorX_Stack_Call{Call: _e.mock.On("Stack")}
}

func (_c *ErrorX_Stack_Call) Run(run func()) *ErrorX_Stack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ErrorX_Stack_Call) Return(_a0 errorsx.Stack) *ErrorX_Stack_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_Stack_Call) RunAndReturn(run func() errorsx.Stack) *ErrorX_Stack_Call {
	_c.Call.Return(run)
	return _c
}

// Unwrap provides a mock function with no fields
func (_m *ErrorX) Unwrap() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Unwrap")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ErrorX_Unwrap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unwrap'
type ErrorX_Unwrap_Call struct {
	*mock.Call
}

// Unwrap is a helper method to define mock.On call
func (_e *ErrorX_Expecter) Unwrap() *ErrorX_Unwrap_Call {
	return &ErrorX_Unwrap_Call{Call: _e.mock.On("Unwrap")}
}

func (_c *ErrorX_Unwrap_Call) Run(run func()) *ErrorX_Unwrap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ErrorX_Unwrap_Call) Return(_a0 error) *ErrorX_Unwrap_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_Unwrap_Call) RunAndReturn(run func() error) *ErrorX_Unwrap_Call {
	_c.Call.Return(run)
	return _c
}

// Wrap provides a mock function with given fields: err
func (_m *ErrorX) Wrap(err error) errorsx.ErrorX {
	ret := _m.Called(err)

	if len(ret) == 0 {
		panic("no return value specified for Wrap")
	}

	var r0 errorsx.ErrorX
	if rf, ok := ret.Get(0).(func(error) errorsx.ErrorX); ok {
		r0 = rf(err)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errorsx.ErrorX)
		}
	}

	return r0
}

// ErrorX_Wrap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wrap'
type ErrorX_Wrap_Call struct {
	*mock.Call
}

// Wrap is a helper method to define mock.On call
//   - err error
func (_e *ErrorX_Expecter) Wrap(err interface{}) *ErrorX_Wrap_Call {
	return &ErrorX_Wrap_Call{Call: _e.mock.On("Wrap", err)}
}

func (_c *ErrorX_Wrap_Call) Run(run func(err error)) *ErrorX_Wrap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *ErrorX_Wrap_Call) Return(_a0 errorsx.ErrorX) *ErrorX_Wrap_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_Wrap_Call) RunAndReturn(run func(error) errorsx.ErrorX) *ErrorX_Wrap_Call {
	_c.Call.Return(run)
	return _c
}

// fields provides a mock function with no fields
func (_m *ErrorX) fields() map[string]any {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for fields")
	}

	var r0 map[string]any
	if rf, ok := ret.Get(0).(func() map[string]any); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]any)
		}
	}

	return r0
}

// ErrorX_fields_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'fields'
type ErrorX_fields_Call struct {
	*mock.Call
}

// fields is a helper method to define mock.On call
func (_e *ErrorX_Expecter) fields() *ErrorX_fields_Call {
	return &ErrorX_fields_Call{Call: _e.mock.On("fields")}
}

func (_c *ErrorX_fields_Call) Run(run func()) *ErrorX_fields_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ErrorX_fields_Call) Return(_a0 map[string]any) *ErrorX_fields_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_fields_Call) RunAndReturn(run func() map[string]any) *ErrorX_fields_Call {
	_c.Call.Return(run)
	return _c
}

// string provides a mock function with no fields
func (_m *ErrorX) string() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for string")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ErrorX_string_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'string'
type ErrorX_string_Call struct {
	*mock.Call
}

// string is a helper method to define mock.On call
func (_e *ErrorX_Expecter) string() *ErrorX_string_Call {
	return &ErrorX_string_Call{Call: _e.mock.On("string")}
}

func (_c *ErrorX_string_Call) Run(run func()) *ErrorX_string_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ErrorX_string_Call) Return(_a0 string) *ErrorX_string_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_string_Call) RunAndReturn(run func() string) *ErrorX_string_Call {
	_c.Call.Return(run)
	return _c
}

// unwrap provides a mock function with no fields
func (_m *ErrorX) unwrap() errorsx.ErrorX {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for unwrap")
	}

	var r0 errorsx.ErrorX
	if rf, ok := ret.Get(0).(func() errorsx.ErrorX); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errorsx.ErrorX)
		}
	}

	return r0
}

// ErrorX_unwrap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'unwrap'
type ErrorX_unwrap_Call struct {
	*mock.Call
}

// unwrap is a helper method to define mock.On call
func (_e *ErrorX_Expecter) unwrap() *ErrorX_unwrap_Call {
	return &ErrorX_unwrap_Call{Call: _e.mock.On("unwrap")}
}

func (_c *ErrorX_unwrap_Call) Run(run func()) *ErrorX_unwrap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ErrorX_unwrap_Call) Return(_a0 errorsx.ErrorX) *ErrorX_unwrap_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ErrorX_unwrap_Call) RunAndReturn(run func() errorsx.ErrorX) *ErrorX_unwrap_Call {
	_c.Call.Return(run)
	return _c
}

// NewErrorX creates a new instance of ErrorX. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewErrorX(t interface {
	mock.TestingT
	Cleanup(func())
}) *ErrorX {
	mock := &ErrorX{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
